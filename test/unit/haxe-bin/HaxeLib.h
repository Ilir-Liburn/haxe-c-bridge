/**
 * HaxeLib.h
 * Automatically generated by HaxeCBridge
 */

#ifndef HaxeCBridge_HaxeLib_h
#define HaxeCBridge_HaxeLib_h
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include "MessagePayload.h"

#ifdef _WIN32
	#ifdef HAXE_C_BRIDGE_EXPORT
		#define DYNAMIC_LINK __declspec(dllexport)
	#else
		#define DYNAMIC_LINK __declspec(dllimport)
	#endif
#else
	#define DYNAMIC_LINK
#endif

typedef void (* HaxeExceptionCallback) (const char* exceptionInfo);
/**
 * Internally haxe strings are stored as null-terminated C strings. Cast to char16_t if you expect utf16 strings.
 * When passed from haxe to C, a reference to the object is retained to prevent garbage collection. You should call releaseHaxeString() when finished with this handle to allow collection.
 */
typedef const char* HaxeString;
/**
 * Represents a pointer to a haxe object.
 * When passed from haxe to C, a reference to the object is retained to prevent garbage collection. You should call releaseHaxeObject() when finished with this handle in C to allow collection.
 */
typedef void* HaxeObject;

typedef HaxeString HaxeLib_NonTrivialAlias;
enum HaxeLib_IntEnum2 {
	AAA = 9,
	BBB = 10,
	CCC = 8
};
typedef enum HaxeLib_IntEnum2 HaxeLib_EnumAlias;
typedef void HaxeLib_AliasA;
typedef HaxeLib_AliasA HaxeLib_CppVoidX;
typedef void (* function_Bool_Void) (bool);
typedef void (* function_Void) (void);
typedef int (* function_Int) (void);
typedef const char* (* function_Int_cpp_ConstCharStar) (int);
typedef int* (* function_cpp_Star_Int__cpp_Star_Int_) (int*);
typedef const char* (* function_CustomStar_Int__cpp_ConstCharStar) (int*);
typedef function_CustomStar_Int__cpp_ConstCharStar HaxeLib_FunctionAlias;
typedef void (* function_MessagePayload_Void) (MessagePayload);
enum HaxeLib_IntEnumAbstract {
	A = 0,
	B = 1
};

#ifdef __cplusplus
extern "C" {
#endif

	/**
	 * Initializes a haxe thread that executes the haxe main() function remains alive indefinitely until told to stop.
	 * 
	 * This must be first before calling haxe functions (otherwise those calls will hang waiting for a response from the haxe thread).
	 * 
	 * @param unhandledExceptionCallback a callback to execute if an unhandled exception occurs on the haxe thread. The haxe thread will continue processing events after an unhandled exception and you may want to stop it after receiving this callback. Use `NULL` for no callback
	 * @returns `NULL` if the thread initializes successfully or a null-terminated C string if an error occurs during initialization
	 */
	DYNAMIC_LINK const char* HaxeLib_initializeHaxeThread(HaxeExceptionCallback unhandledExceptionCallback);

	/**
	 * Stops the haxe thread, blocking until the thread has completed. Once ended, it cannot be restarted (this is because static variable state will be retained from the last run).
	 *
	 * Other threads spawned from the haxe thread may still be running (you must arrange to stop these yourself for safe app shutdown).
	 *
	 * It can be safely called any number of times – if the haxe thread is not running this function will just return.
	 * 
	 * After executing no more calls to main-thread haxe functions can be made (as these will hang waiting for a response from the main thread).
	 * 
	 * Thread-safety: Can be called safely called on any thread. If called on the haxe thread it will trigger the thread to stop but it cannot then block until stopped.
	 *
	 * @param waitOnScheduledEvents If `true`, this function will wait for all events scheduled to execute in the future on the haxe thread to complete – this is the same behavior as running a normal hxcpp program. If `false`, immediate pending events will be finished and the thread stopped without executing events scheduled in the future
	 */
	DYNAMIC_LINK void HaxeLib_stopHaxeThreadIfRunning(bool waitOnScheduledEvents);

	/**
	 * Informs the garbage collector that the string is no longer needed by the C code.
	 * 
	 * If the object has no remaining reference the garbage collector can free the associated memory (which can happen at any time in the future). It does not free the memory immediately.
	 * 
	 * Thread-safety: can be called on any thread.
	 * 
	 * @param haxeString a handle to a haxe string returned from a haxe function
	 */
	DYNAMIC_LINK void HaxeLib_releaseHaxeString(HaxeString haxeString);

	/**
	 * Informs the garbage collector that object is no longer needed by the C code.
	 * 
	 * If the object has no remaining reference the garbage collector can free the associated memory (which can happen at any time in the future). It does not free the memory immediately.
	 * 
	 * Thread-safety: can be called on any thread.
	 * 
	 * @param haxeObject a handle to an arbitrary haxe object returned from a haxe function
	 */
	DYNAMIC_LINK void HaxeLib_releaseHaxeObject(HaxeObject haxeObject);

	/**
	 * Some doc
	 * @param a some integer
	 * @param b some string
	 * @returns void
	 */
	DYNAMIC_LINK void HaxeLib_voidRtn(int a, HaxeString b, HaxeLib_NonTrivialAlias c, HaxeLib_EnumAlias e);

	DYNAMIC_LINK void HaxeNoArgsNoReturn();

	/**
	 * when called externally from C this function will be executed synchronously on the main thread
	 */
	DYNAMIC_LINK bool HaxeLib_callInMainThread(double f64);

	/**
	 * When called externally from C this function will be executed on the calling thread.
	 * Beware: you cannot interact with the rest of your code without first synchronizing with the main thread (or risk crashes)
	 */
	DYNAMIC_LINK bool HaxeLib_callInExternalThread(double f64);

	DYNAMIC_LINK int HaxeLib_add(int a, int b);

	DYNAMIC_LINK int* HaxeLib_starPointers(void* starVoid, HaxeLib_CppVoidX* starVoid2, HaxeLib_CppVoidX* customStar, int** customStar2, const void* constStarVoid, int* starInt, const char* constCharStar);

	DYNAMIC_LINK void* HaxeLib_rawPointers(void* rawPointer, int64_t* rawInt64Pointer, const void* rawConstPointer);

	DYNAMIC_LINK int64_t* HaxeLib_hxcppPointers(function_Bool_Void assert, void* pointer, int64_t* int64Array, int int64ArrayLength, const void* constPointer);

	DYNAMIC_LINK function_Int_cpp_ConstCharStar HaxeLib_hxcppCallbacks(function_Bool_Void assert, function_Void voidVoid, function_Int voidInt, function_Int_cpp_ConstCharStar intString, function_cpp_Star_Int__cpp_Star_Int_ pointers, HaxeLib_FunctionAlias fnAlias, function_MessagePayload_Void fnStruct);

	DYNAMIC_LINK MessagePayload HaxeLib_externStruct(MessagePayload v, MessagePayload* vStar);

	DYNAMIC_LINK int* HaxeLib_getHaxeArray(int* length);

	DYNAMIC_LINK int64_t* HaxeLib_getHaxeArrayStr(int* length);

	/**
	 * Test the GC behavior, runs on haxe main thread
	 */
	DYNAMIC_LINK void HaxeLib_allocateABunchOfData();

	/**
	 * Test the GC behavior, runs on external (but hxcpp attached) thread
	 */
	DYNAMIC_LINK void HaxeLib_allocateABunchOfDataExternalThread();

	DYNAMIC_LINK enum HaxeLib_IntEnum2 HaxeLib_enumTypes(enum HaxeLib_IntEnumAbstract e, const char* s, HaxeLib_EnumAlias a);

	DYNAMIC_LINK void HaxeLib_cppCoreTypes(size_t sizet, char char_, const char* constCharStar);

	/**
	 * single-line doc
	 */
	DYNAMIC_LINK uint64_t HaxeLib_cppCoreTypes2(int i, double f, float s, signed char i8, short i16, int i32, int64_t i64, uint64_t ui64, const char* str);

	DYNAMIC_LINK HaxeObject HaxeLib_createHaxeAnon();

	DYNAMIC_LINK void HaxeLib_checkHaxeAnon(HaxeObject obj);

	DYNAMIC_LINK void HaxeLib_checkAnonFromPointer(void* haxeObject);

	DYNAMIC_LINK HaxeObject HaxeLib_createHaxeMap();

	DYNAMIC_LINK void HaxeLib_checkHaxeMap(HaxeObject m);

	DYNAMIC_LINK void HaxeLib_checkNull(HaxeObject m, double f);

	DYNAMIC_LINK HaxeObject HaxeLib_createCustomType();

	DYNAMIC_LINK void HaxeLib_checkCustomType(HaxeObject x);

	DYNAMIC_LINK HaxeString HaxeLib_createHaxeString();

	DYNAMIC_LINK void HaxeLib_checkHaxeString(HaxeString str);

	DYNAMIC_LINK void HaxeLib_throwException();

	DYNAMIC_LINK void HaxeLib_Main_stopLoopingAfterTime_ms(int milliseconds);

	DYNAMIC_LINK int HaxeLib_Main_getLoopCount();

	DYNAMIC_LINK int HaxeLib_Main_hxcppGcMemUsage();

	DYNAMIC_LINK int HaxeLib_Main_hxcppGcMemUsageExternal();

	DYNAMIC_LINK void HaxeLib_Main_hxcppGcRun(bool major);

	DYNAMIC_LINK void HaxeLib_Main_printTime();

	DYNAMIC_LINK int HaxeLib_pack__ExampleClass_ExampleClassPrivate_examplePrivate();

	DYNAMIC_LINK int ExamplePrefix_example();

	DYNAMIC_LINK HaxeObject HaxeLib_Instance_new(HaxeString exampleArg);

	DYNAMIC_LINK void HaxeLib_Instance_methodNoArgs(HaxeObject instance);

	DYNAMIC_LINK int HaxeLib_Instance_methodAdd(HaxeObject instance, int a, int b);

	DYNAMIC_LINK HaxeString HaxeLib_Instance_overrideMe(HaxeObject instance);

	DYNAMIC_LINK void HaxeLib_Instance_staticMethod();

#ifdef __cplusplus
}
#endif

#undef DYNAMIC_LINK

#endif /* HaxeCBridge_HaxeLib_h */
