/**
 * HaxeLib.cpp
 * Automatically generated by HaxeEmbed
 */
#include <atomic>
#include <hxcpp.h>
#include <hx/Native.h>
#include <hx/Thread.h>
#include <hx/StdLibs.h>
#include <HaxeEmbed.h>

#include "../HaxeLib.h"

#include <test/HxPublicApi.h>
#include <pack/_ExampleClass/ExampleClassPrivate.h>
#include <pack/ExampleClass.h>

extern "C" void __hxcpp_main();

namespace {
	std::atomic<bool> threadStarted = { false };
	std::atomic<bool> threadRunning = { false };
	// once haxe statics are initialized we cannot clear them for a clean restart
	std::atomic<bool> staticsInitialized = { false };

	struct HaxeThreadData {
		HaxeExceptionCallback haxeExceptionCallback;
		const char* initExceptionInfo;
	};

	HxSemaphore threadInitSemaphore;
	HxSemaphore threadEndSemaphore;
	HxMutex threadManageMutex;

	void defaultExceptionHandler(const char* info) {
		printf("Unhandled haxe exception: %s\n", info);
	}
}

THREAD_FUNC_TYPE haxeMainThreadFunc(void *data) {
	HX_TOP_OF_STACK
	threadRunning = true;

	HaxeThreadData* threadData = (HaxeThreadData*) data;
	threadData->initExceptionInfo = nullptr;

	// copy out callback
	HaxeExceptionCallback haxeExceptionCallback = threadData->haxeExceptionCallback;

	bool firstRun = !staticsInitialized;

	// See hx::Init in StdLibs.cpp for reference
	if (!staticsInitialized) try {
		::hx::Boot();
		__boot_all();
		staticsInitialized = true;
	} catch(Dynamic initException) {
		// hxcpp init failure or uncaught haxe runtime exception
		threadData->initExceptionInfo = initException->toString().utf8_str();
	}

	threadInitSemaphore.Set();

	if (staticsInitialized) { // initialized without error
		bool exitRequested = false;
		if (firstRun) {
			// this will block until all pending events created from main() have completed
			exitRequested = HaxeEmbed::runUserMain(__hxcpp_main, haxeExceptionCallback);
		}

		// we want to keep alive the thread after main() has completed, so we run the event loop until we want to terminate the thread
		if (!exitRequested) {
			HaxeEmbed::endlessEventLoop(haxeExceptionCallback);
		}
	}

	threadRunning = false;
	threadEndSemaphore.Set();

	THREAD_FUNC_RET
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_initializeHaxeThread(HaxeExceptionCallback unhandledExceptionCallback) {
	HaxeThreadData threadData = {
		.haxeExceptionCallback = unhandledExceptionCallback == nullptr ? defaultExceptionHandler : unhandledExceptionCallback,
		.initExceptionInfo = nullptr,
	};

	{
		// mutex prevents two threads calling this function from being able to start two haxe threads
		AutoLock lock(threadManageMutex);
		if (!threadStarted) {
			// startup the haxe main thread
			HxCreateDetachedThread(haxeMainThreadFunc, &threadData);

			threadStarted = true;

			// wait until the thread is initialized and ready
			threadInitSemaphore.Wait();
		} else {
			threadData.initExceptionInfo = "haxe thread cannot be started twice";
		}
	}
				
	if (threadData.initExceptionInfo != nullptr) {
		HaxeLib_stopHaxeThread();

		const int returnInfoMax = 1024;
		static char returnInfo[returnInfoMax] = ""; // statically allocated for return safety
		strncpy(returnInfo, threadData.initExceptionInfo, returnInfoMax);
		return returnInfo;
	} else {
		return nullptr;
	}
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_stopHaxeThread() {
	// it is possible for stopHaxeThread to be called from within the haxe thread, while another thread is waiting on threadEndSemaphore
	// the idea here is only one stopHaxeThread can running at a time, if stop has already been called, subsequent stops will return immediately
	bool stopped = false;
	if (threadManageMutex.TryLock()) {
		if (threadRunning) {
			hx::NativeAttach autoAttach;
			bool isMain = HaxeEmbed::isMainThread();
			HaxeEmbed::endMainThread();
			if (!isMain) {
				threadEndSemaphore.Wait();
			}
		}
		stopped = true;
		threadManageMutex.Unlock();
	}
	return stopped;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_voidRtn(int a0, const char* a1, HaxeLib_NonTrivialAlias a2, HaxeLib_EnumAlias a3) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::voidRtn(a0, a1, a2, a3);
	}

	// queue a callback to execute voidRtn() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; const char* a1; HaxeLib_NonTrivialAlias a2; HaxeLib_EnumAlias a3;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::voidRtn(data->args.a0, data->args.a1, data->args.a2, data->args.a3);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_noArgsNoReturn() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::noArgsNoReturn();
	}

	// queue a callback to execute noArgsNoReturn() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::noArgsNoReturn();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_callInMainThread(double a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::callInMainThread(a0);
	}

	// queue a callback to execute callInMainThread() on the main thread and wait until execution completes
	struct Data {
		struct {double a0;} args;
		HxSemaphore lock;
		bool ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::callInMainThread(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_callInExternalThread(double a0) {
	hx::NativeAttach autoAttach;
	return test::HxPublicApi_obj::callInExternalThread(a0);
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_add(int a0, int a1) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::add(a0, a1);
	}

	// queue a callback to execute add() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; int a1;} args;
		HxSemaphore lock;
		int ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::add(data->args.a0, data->args.a1);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int* HaxeLib_starPointers(void* a0, HaxeLib_CppVoidX* a1, HaxeLib_CppVoidX* a2, int** a3, const void* a4, int* a5, const char* a6) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::starPointers(a0, a1, a2, a3, a4, a5, a6);
	}

	// queue a callback to execute starPointers() on the main thread and wait until execution completes
	struct Data {
		struct {void* a0; HaxeLib_CppVoidX* a1; HaxeLib_CppVoidX* a2; int** a3; const void* a4; int* a5; const char* a6;} args;
		HxSemaphore lock;
		int* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::starPointers(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4, data->args.a5, data->args.a6);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5, a6} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void* HaxeLib_rawPointers(void* a0, int64_t* a1, const void* a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::rawPointers(a0, a1, a2);
	}

	// queue a callback to execute rawPointers() on the main thread and wait until execution completes
	struct Data {
		struct {void* a0; int64_t* a1; const void* a2;} args;
		HxSemaphore lock;
		void* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::rawPointers(data->args.a0, data->args.a1, data->args.a2);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int64_t* HaxeLib_hxcppPointers(function_Bool_Void a0, void* a1, int64_t* a2, int a3, const void* a4) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::hxcppPointers(a0, a1, a2, a3, a4);
	}

	// queue a callback to execute hxcppPointers() on the main thread and wait until execution completes
	struct Data {
		struct {function_Bool_Void a0; void* a1; int64_t* a2; int a3; const void* a4;} args;
		HxSemaphore lock;
		int64_t* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::hxcppPointers(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3, a4} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
function_Int_cpp_ConstCharStar HaxeLib_hxcppCallbacks(function_Bool_Void a0, function_Void a1, function_Int a2, function_Int_cpp_ConstCharStar a3, function_cpp_Star_Int__cpp_Star_Int_ a4, HaxeLib_FunctionAlias a5) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::hxcppCallbacks(a0, a1, a2, a3, a4, a5);
	}

	// queue a callback to execute hxcppCallbacks() on the main thread and wait until execution completes
	struct Data {
		struct {function_Bool_Void a0; function_Void a1; function_Int a2; function_Int_cpp_ConstCharStar a3; function_cpp_Star_Int__cpp_Star_Int_ a4; HaxeLib_FunctionAlias a5;} args;
		HxSemaphore lock;
		function_Int_cpp_ConstCharStar ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::hxcppCallbacks(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4, data->args.a5);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
MessagePayload HaxeLib_externStruct(MessagePayload a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::externStruct(a0);
	}

	// queue a callback to execute externStruct() on the main thread and wait until execution completes
	struct Data {
		struct {MessagePayload a0;} args;
		HxSemaphore lock;
		MessagePayload ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::externStruct(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_optional(float a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::optional(a0);
	}

	// queue a callback to execute optional() on the main thread and wait until execution completes
	struct Data {
		struct {float a0;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::optional(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_badOptional(float a0, float a1) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::badOptional(a0, a1);
	}

	// queue a callback to execute badOptional() on the main thread and wait until execution completes
	struct Data {
		struct {float a0; float a1;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::badOptional(data->args.a0, data->args.a1);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
enum HaxeLib_IntEnum2 HaxeLib_enumTypes(enum HaxeLib_IntEnumAbstract a0, const char* a1, HaxeLib_EnumAlias a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return static_cast<enum HaxeLib_IntEnum2>(test::HxPublicApi_obj::enumTypes(a0, a1, a2));
	}

	// queue a callback to execute enumTypes() on the main thread and wait until execution completes
	struct Data {
		struct {enum HaxeLib_IntEnumAbstract a0; const char* a1; HaxeLib_EnumAlias a2;} args;
		HxSemaphore lock;
		enum HaxeLib_IntEnum2 ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = static_cast<enum HaxeLib_IntEnum2>(test::HxPublicApi_obj::enumTypes(data->args.a0, data->args.a1, data->args.a2));
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_cppCoreTypes(size_t a0, char a1, const char* a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::cppCoreTypes(a0, a1, a2);
	}

	// queue a callback to execute cppCoreTypes() on the main thread and wait until execution completes
	struct Data {
		struct {size_t a0; char a1; const char* a2;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::cppCoreTypes(data->args.a0, data->args.a1, data->args.a2);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_somePublicMethod(int a0, double a1, float a2, signed char a3, short a4, int a5, int64_t a6, uint64_t a7, const char* a8) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::somePublicMethod(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}

	// queue a callback to execute somePublicMethod() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; double a1; float a2; signed char a3; short a4; int a5; int64_t a6; uint64_t a7; const char* a8;} args;
		HxSemaphore lock;
		int ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::somePublicMethod(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4, data->args.a5, data->args.a6, data->args.a7, data->args.a8);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5, a6, a7, a8} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_throwException() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::throwException();
	}

	// queue a callback to execute throwException() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::throwException();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_pack__ExampleClass_ExampleClassPrivate_examplePrivate() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return pack::_ExampleClass::ExampleClassPrivate_obj::examplePrivate();
	}

	// queue a callback to execute examplePrivate() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
		const char* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = pack::_ExampleClass::ExampleClassPrivate_obj::examplePrivate();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_pack_ExampleClass_example() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return pack::ExampleClass_obj::example();
	}

	// queue a callback to execute example() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
		const char* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = pack::ExampleClass_obj::example();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

