/**
 * HaxeLib.cpp
 * Automatically generated by HaxeEmbed
 */
#include <hxcpp.h>
#include <hx/Native.h>
#include <hx/Thread.h>
#include <hx/StdLibs.h>
#include <HaxeEmbed.h>
#include <_HaxeEmbed/EndThreadException.h>

#include "../HaxeLib.h"

#include <test/HxPublicApi.h>
#include <pack/_ExampleClass/ExampleClassPrivate.h>
#include <pack/ExampleClass.h>

extern "C" void __hxcpp_main();

namespace {
	bool threadInitialized = false;
	const char* threadInitExceptionInfo = nullptr;
	HxSemaphore threadInitSemaphore;
	HxSemaphore threadEndSemaphore;
	HxMutex threadManageMutex;
	HaxeExceptionCallback haxeExceptionCallback = nullptr;
}

THREAD_FUNC_TYPE haxeMainThreadFunc(void *data) {
	// reset the exception info
	threadInitExceptionInfo = nullptr;

	// See hx::Init in StdLibs.cpp for reference
	try {

		HX_TOP_OF_STACK
		::hx::Boot();
		__boot_all();

	} catch(Dynamic initException) {

		// hxcpp init failure or uncaught haxe runtime exception
		HX_TOP_OF_STACK
		threadInitExceptionInfo = initException->toString().utf8_str();

	}

	threadInitSemaphore.Set();

	if (threadInitExceptionInfo == nullptr) { // initialized without error
		try {

			// this will block until all pending events created from main() have completed
			__hxcpp_main();

			// we want to keep alive the thread after main() has completed, so we run the event loop until we want to terminate the thread
			HaxeEmbed::endlessEventLoop();

		} catch(Dynamic runtimeException) {

			// An EndThreadException is used to break out of the event loop, we do not need to report this exception
			if (!runtimeException.IsClass<_HaxeEmbed::EndThreadException>()) {
				if (haxeExceptionCallback != nullptr) {
					const char* info = runtimeException->toString().utf8_str();
					haxeExceptionCallback(info);
				}
			}

		}
	}

	threadEndSemaphore.Set();

	THREAD_FUNC_RET
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_startHaxeThread(HaxeExceptionCallback unhandledExceptionCallback) {
	threadManageMutex.Lock();

	if (threadInitialized) return nullptr;

	haxeExceptionCallback = unhandledExceptionCallback;

	// startup the haxe main thread
	HxCreateDetachedThread(haxeMainThreadFunc, nullptr);

	// wait until the thread is initialized and ready
	threadInitSemaphore.Wait();

	threadInitialized = true;

	threadManageMutex.Unlock();

	return threadInitExceptionInfo;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_stopHaxeThread() {
	threadManageMutex.Lock();

	if (!threadInitialized) return;

	hx::NativeAttach autoAttach;

	// queue an exception into the event loop so we break out of the loop and end the thread
	HaxeEmbed::endMainThread();

	// block until the thread ends, the haxe thread will first execute all immediately pending events
	threadEndSemaphore.Wait();

	threadInitialized = false;

	threadManageMutex.Unlock();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_voidRtn(int a0, const char* a1) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::voidRtn(a0, (const char*) a1);
	}

	// queue a callback to execute voidRtn() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; const char* a1;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			test::HxPublicApi_obj::voidRtn(data->args.a0, (const char*) data->args.a1);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_noArgsNoReturn() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::noArgsNoReturn();
	}

	// queue a callback to execute noArgsNoReturn() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			test::HxPublicApi_obj::noArgsNoReturn();
			data->lock.Set();
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_callInMainThread(double a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::callInMainThread(a0);
	}

	// queue a callback to execute callInMainThread() on the main thread and wait until execution completes
	struct Data {
		struct {double a0;} args;
		HxSemaphore lock;
		bool ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			data->ret = test::HxPublicApi_obj::callInMainThread(data->args.a0);
			data->lock.Set();
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_callInExternalThread(double a0) {
	hx::NativeAttach autoAttach;
	return test::HxPublicApi_obj::callInExternalThread(a0);
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_add(int a0, int a1) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::add(a0, a1);
	}

	// queue a callback to execute add() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; int a1;} args;
		HxSemaphore lock;
		int ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			data->ret = test::HxPublicApi_obj::add(data->args.a0, data->args.a1);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int* HaxeLib_starPointers(void* a0, HaxeLib_CppVoidX* a1, HaxeLib_CppVoidX* a2, int** a3, const void* a4, int* a5, const char* a6) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::starPointers((void*) a0, (void*) a1, (void*) a2, (int**) a3, (const void*) a4, (int*) a5, (const char*) a6);
	}

	// queue a callback to execute starPointers() on the main thread and wait until execution completes
	struct Data {
		struct {void* a0; HaxeLib_CppVoidX* a1; HaxeLib_CppVoidX* a2; int** a3; const void* a4; int* a5; const char* a6;} args;
		HxSemaphore lock;
		int* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			data->ret = test::HxPublicApi_obj::starPointers((void*) data->args.a0, (void*) data->args.a1, (void*) data->args.a2, (int**) data->args.a3, (const void*) data->args.a4, (int*) data->args.a5, (const char*) data->args.a6);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5, a6} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_rawPointers(void* a0, int64_t* a1, const void* a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::rawPointers((void*) a0, (int64_t*) a1, (const void*) a2);
	}

	// queue a callback to execute rawPointers() on the main thread and wait until execution completes
	struct Data {
		struct {void* a0; int64_t* a1; const void* a2;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			test::HxPublicApi_obj::rawPointers((void*) data->args.a0, (int64_t*) data->args.a1, (const void*) data->args.a2);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_hxcppPointers(void* a0, int64_t* a1, const void* a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::hxcppPointers((void*) a0, (int64_t*) a1, (const void*) a2);
	}

	// queue a callback to execute hxcppPointers() on the main thread and wait until execution completes
	struct Data {
		struct {void* a0; int64_t* a1; const void* a2;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			test::HxPublicApi_obj::hxcppPointers((void*) data->args.a0, (int64_t*) data->args.a1, (const void*) data->args.a2);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
function_Void HaxeLib_hxcppCallbacks(function_Void a0, function_Int a1, function_Int_String a2, function_String_Int a3, function_Int_Void a4, function_cpp_Pointer_Int__cpp_Pointer_Int_ a5, HaxeLib_FunctionAlias a6) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::hxcppCallbacks(hx::AnyCast(a0), hx::AnyCast(a1), hx::AnyCast(a2), hx::AnyCast(a3), hx::AnyCast(a4), hx::AnyCast(a5), hx::AnyCast(a6));
	}

	// queue a callback to execute hxcppCallbacks() on the main thread and wait until execution completes
	struct Data {
		struct {function_Void a0; function_Int a1; function_Int_String a2; function_String_Int a3; function_Int_Void a4; function_cpp_Pointer_Int__cpp_Pointer_Int_ a5; HaxeLib_FunctionAlias a6;} args;
		HxSemaphore lock;
		function_Void ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			data->ret = test::HxPublicApi_obj::hxcppCallbacks(hx::AnyCast(data->args.a0), hx::AnyCast(data->args.a1), hx::AnyCast(data->args.a2), hx::AnyCast(data->args.a3), hx::AnyCast(data->args.a4), hx::AnyCast(data->args.a5), hx::AnyCast(data->args.a6));
			data->lock.Set();
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5, a6} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
MessagePayload HaxeLib_externStruct(MessagePayload a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::externStruct(a0);
	}

	// queue a callback to execute externStruct() on the main thread and wait until execution completes
	struct Data {
		struct {MessagePayload a0;} args;
		HxSemaphore lock;
		MessagePayload ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			data->ret = test::HxPublicApi_obj::externStruct(data->args.a0);
			data->lock.Set();
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_optional(float a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::optional(a0);
	}

	// queue a callback to execute optional() on the main thread and wait until execution completes
	struct Data {
		struct {float a0;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			test::HxPublicApi_obj::optional(data->args.a0);
			data->lock.Set();
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_badOptional(float a0, float a1) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::badOptional(a0, a1);
	}

	// queue a callback to execute badOptional() on the main thread and wait until execution completes
	struct Data {
		struct {float a0; float a1;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			test::HxPublicApi_obj::badOptional(data->args.a0, data->args.a1);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_enumTypes(enum HaxeLib_IntEnumAbstract a0, const char* a1, HaxeLib_EnumAlias a2, enum HaxeLib_IndirectlyReferencedEnum* a3, enum HaxeLib_IndirectlyReferencedEnum** a4) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::enumTypes(a0, (const char*) a1, a2, (int*) a3, (int**) a4);
	}

	// queue a callback to execute enumTypes() on the main thread and wait until execution completes
	struct Data {
		struct {enum HaxeLib_IntEnumAbstract a0; const char* a1; HaxeLib_EnumAlias a2; enum HaxeLib_IndirectlyReferencedEnum* a3; enum HaxeLib_IndirectlyReferencedEnum** a4;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			test::HxPublicApi_obj::enumTypes(data->args.a0, (const char*) data->args.a1, data->args.a2, (int*) data->args.a3, (int**) data->args.a4);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1, a2, a3, a4} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_cppCoreTypes(size_t a0, char a1, const char* a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::cppCoreTypes(a0, a1, (const char*) a2);
	}

	// queue a callback to execute cppCoreTypes() on the main thread and wait until execution completes
	struct Data {
		struct {size_t a0; char a1; const char* a2;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			test::HxPublicApi_obj::cppCoreTypes(data->args.a0, data->args.a1, (const char*) data->args.a2);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_somePublicMethod(int a0, double a1, float a2, signed char a3, short a4, int a5, int64_t a6, uint64_t a7, const char* a8) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::somePublicMethod(a0, a1, a2, a3, a4, a5, a6, a7, (const char*) a8);
	}

	// queue a callback to execute somePublicMethod() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; double a1; float a2; signed char a3; short a4; int a5; int64_t a6; uint64_t a7; const char* a8;} args;
		HxSemaphore lock;
		int ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			data->ret = test::HxPublicApi_obj::somePublicMethod(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4, data->args.a5, data->args.a6, data->args.a7, (const char*) data->args.a8);
			data->lock.Set();
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5, a6, a7, a8} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_pack__ExampleClass_ExampleClassPrivate_examplePrivate() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return pack::_ExampleClass::ExampleClassPrivate_obj::examplePrivate();
	}

	// queue a callback to execute examplePrivate() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
		const char* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			data->ret = pack::_ExampleClass::ExampleClassPrivate_obj::examplePrivate();
			data->lock.Set();
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_pack_ExampleClass_example() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return pack::ExampleClass_obj::example();
	}

	// queue a callback to execute example() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
		const char* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			data->ret = pack::ExampleClass_obj::example();
			data->lock.Set();
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

