/**
 * HaxeLib.cpp
 * Automatically generated by HaxeEmbed
 */
#include <atomic>
#include <hxcpp.h>
#include <hx/Native.h>
#include <hx/Thread.h>
#include <hx/StdLibs.h>
#include <HaxeEmbed.h>

#include "../HaxeLib.h"

#include <test/HxPublicApi.h>
#include <pack/_ExampleClass/ExampleClassPrivate.h>
#include <pack/ExampleClass.h>

extern "C" void __hxcpp_main();

namespace {
	std::atomic<bool> threadActive = { false };
	// once haxe statics are initialized we cannot clear them for a clean restart
	std::atomic<bool> staticsInitialized = { false };

	struct HaxeThreadData {
		HaxeExceptionCallback haxeExceptionCallback;
		const char* initExceptionInfo;
	};

	HxSemaphore threadInitSemaphore;
	HxSemaphore threadEndSemaphore;
	HxMutex threadManageMutex;

	void defaultExceptionHandler(const char* info) {
		printf("Unhandled haxe exception: %s\n", info);
	}
}

THREAD_FUNC_TYPE haxeMainThreadFunc(void *data) {
	HX_TOP_OF_STACK

	HaxeThreadData* threadData = (HaxeThreadData*) data;
	threadData->initExceptionInfo = nullptr;

	// copy out callback
	HaxeExceptionCallback haxeExceptionCallback = threadData->haxeExceptionCallback;

	bool firstRun = !staticsInitialized;

	// See hx::Init in StdLibs.cpp for reference
	if (!staticsInitialized) try {
		::hx::Boot();
		__boot_all();
		staticsInitialized = true;
	} catch(Dynamic initException) {
		// hxcpp init failure or uncaught haxe runtime exception
		threadData->initExceptionInfo = initException->toString().utf8_str();
	}

	threadInitSemaphore.Set();

	if (staticsInitialized) { // initialized without error
		threadActive = true;

		bool exitRequested = false;
		if (firstRun) {
			// this will block until all pending events created from main() have completed
			exitRequested = HaxeEmbed::runUserMain(__hxcpp_main, haxeExceptionCallback);
		}

		// we want to keep alive the thread after main() has completed, so we run the event loop until we want to terminate the thread
		if (!exitRequested) {
			HaxeEmbed::endlessEventLoop(haxeExceptionCallback);
		}

		threadActive = false;
	}

	threadEndSemaphore.Set();

	THREAD_FUNC_RET
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_initializeHaxeThread(HaxeExceptionCallback unhandledExceptionCallback) {
	threadManageMutex.Lock();

	if (threadActive) {
		static const char* info = "haxe thread already running";
		return info;
	}

	if (staticsInitialized) {
		static const char* info = "haxe thread cannot be restarted once stopped";
		return info;
	}

	HaxeThreadData threadData = {
		.haxeExceptionCallback = unhandledExceptionCallback == nullptr ? defaultExceptionHandler : unhandledExceptionCallback,
		.initExceptionInfo = nullptr,
	};

	// startup the haxe main thread
	HxCreateDetachedThread(haxeMainThreadFunc, &threadData);

	// wait until the thread is initialized and ready
	threadInitSemaphore.Wait();

	threadManageMutex.Unlock();
				
	if (threadData.initExceptionInfo != nullptr) {
		HaxeLib_stopHaxeThread();

		const int returnInfoMax = 1024;
		static char returnInfo[returnInfoMax] = ""; // statically allocated for return safety
		strncpy(returnInfo, threadData.initExceptionInfo, returnInfoMax);
		return returnInfo;
	} else {
		return nullptr;
	}
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_stopHaxeThread() {
	threadManageMutex.Lock();

	if (!threadActive) return;

	hx::NativeAttach autoAttach;

	// queue an exception into the event loop so we break out of the loop and end the thread
	HaxeEmbed::endMainThread();

	// block until the thread ends, the haxe thread will first execute all immediately pending events
	threadEndSemaphore.Wait();

	threadManageMutex.Unlock();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_voidRtn(int a0, const char* a1) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::voidRtn(a0, (const char*) a1);
	}

	// queue a callback to execute voidRtn() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; const char* a1;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::voidRtn(data->args.a0, (const char*) data->args.a1);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_noArgsNoReturn() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::noArgsNoReturn();
	}

	// queue a callback to execute noArgsNoReturn() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::noArgsNoReturn();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_callInMainThread(double a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::callInMainThread(a0);
	}

	// queue a callback to execute callInMainThread() on the main thread and wait until execution completes
	struct Data {
		struct {double a0;} args;
		HxSemaphore lock;
		bool ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::callInMainThread(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_callInExternalThread(double a0) {
	hx::NativeAttach autoAttach;
	return test::HxPublicApi_obj::callInExternalThread(a0);
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_add(int a0, int a1) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::add(a0, a1);
	}

	// queue a callback to execute add() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; int a1;} args;
		HxSemaphore lock;
		int ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::add(data->args.a0, data->args.a1);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int* HaxeLib_starPointers(void* a0, HaxeLib_CppVoidX* a1, HaxeLib_CppVoidX* a2, int** a3, const void* a4, int* a5, const char* a6) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::starPointers((void*) a0, (void*) a1, (void*) a2, (int**) a3, (const void*) a4, (int*) a5, (const char*) a6);
	}

	// queue a callback to execute starPointers() on the main thread and wait until execution completes
	struct Data {
		struct {void* a0; HaxeLib_CppVoidX* a1; HaxeLib_CppVoidX* a2; int** a3; const void* a4; int* a5; const char* a6;} args;
		HxSemaphore lock;
		int* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::starPointers((void*) data->args.a0, (void*) data->args.a1, (void*) data->args.a2, (int**) data->args.a3, (const void*) data->args.a4, (int*) data->args.a5, (const char*) data->args.a6);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5, a6} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_rawPointers(void* a0, int64_t* a1, const void* a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::rawPointers((void*) a0, (int64_t*) a1, (const void*) a2);
	}

	// queue a callback to execute rawPointers() on the main thread and wait until execution completes
	struct Data {
		struct {void* a0; int64_t* a1; const void* a2;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::rawPointers((void*) data->args.a0, (int64_t*) data->args.a1, (const void*) data->args.a2);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_hxcppPointers(void* a0, int64_t* a1, const void* a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::hxcppPointers((void*) a0, (int64_t*) a1, (const void*) a2);
	}

	// queue a callback to execute hxcppPointers() on the main thread and wait until execution completes
	struct Data {
		struct {void* a0; int64_t* a1; const void* a2;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::hxcppPointers((void*) data->args.a0, (int64_t*) data->args.a1, (const void*) data->args.a2);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
function_Void HaxeLib_hxcppCallbacks(function_Void a0, function_Int a1, function_Int_String a2, function_String_Int a3, function_Int_Void a4, function_cpp_Pointer_Int__cpp_Pointer_Int_ a5, HaxeLib_FunctionAlias a6) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::hxcppCallbacks(hx::AnyCast(a0), hx::AnyCast(a1), hx::AnyCast(a2), hx::AnyCast(a3), hx::AnyCast(a4), hx::AnyCast(a5), hx::AnyCast(a6));
	}

	// queue a callback to execute hxcppCallbacks() on the main thread and wait until execution completes
	struct Data {
		struct {function_Void a0; function_Int a1; function_Int_String a2; function_String_Int a3; function_Int_Void a4; function_cpp_Pointer_Int__cpp_Pointer_Int_ a5; HaxeLib_FunctionAlias a6;} args;
		HxSemaphore lock;
		function_Void ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::hxcppCallbacks(hx::AnyCast(data->args.a0), hx::AnyCast(data->args.a1), hx::AnyCast(data->args.a2), hx::AnyCast(data->args.a3), hx::AnyCast(data->args.a4), hx::AnyCast(data->args.a5), hx::AnyCast(data->args.a6));
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5, a6} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
MessagePayload HaxeLib_externStruct(MessagePayload a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::externStruct(a0);
	}

	// queue a callback to execute externStruct() on the main thread and wait until execution completes
	struct Data {
		struct {MessagePayload a0;} args;
		HxSemaphore lock;
		MessagePayload ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::externStruct(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_optional(float a0) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::optional(a0);
	}

	// queue a callback to execute optional() on the main thread and wait until execution completes
	struct Data {
		struct {float a0;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::optional(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_badOptional(float a0, float a1) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::badOptional(a0, a1);
	}

	// queue a callback to execute badOptional() on the main thread and wait until execution completes
	struct Data {
		struct {float a0; float a1;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::badOptional(data->args.a0, data->args.a1);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_enumTypes(enum HaxeLib_IntEnumAbstract a0, const char* a1, HaxeLib_EnumAlias a2, enum HaxeLib_IndirectlyReferencedEnum* a3, enum HaxeLib_IndirectlyReferencedEnum** a4) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::enumTypes(a0, (const char*) a1, a2, (int*) a3, (int**) a4);
	}

	// queue a callback to execute enumTypes() on the main thread and wait until execution completes
	struct Data {
		struct {enum HaxeLib_IntEnumAbstract a0; const char* a1; HaxeLib_EnumAlias a2; enum HaxeLib_IndirectlyReferencedEnum* a3; enum HaxeLib_IndirectlyReferencedEnum** a4;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::enumTypes(data->args.a0, (const char*) data->args.a1, data->args.a2, (int*) data->args.a3, (int**) data->args.a4);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3, a4} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_cppCoreTypes(size_t a0, char a1, const char* a2) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::cppCoreTypes(a0, a1, (const char*) a2);
	}

	// queue a callback to execute cppCoreTypes() on the main thread and wait until execution completes
	struct Data {
		struct {size_t a0; char a1; const char* a2;} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::cppCoreTypes(data->args.a0, data->args.a1, (const char*) data->args.a2);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_somePublicMethod(int a0, double a1, float a2, signed char a3, short a4, int a5, int64_t a6, uint64_t a7, const char* a8) {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::somePublicMethod(a0, a1, a2, a3, a4, a5, a6, a7, (const char*) a8);
	}

	// queue a callback to execute somePublicMethod() on the main thread and wait until execution completes
	struct Data {
		struct {int a0; double a1; float a2; signed char a3; short a4; int a5; int64_t a6; uint64_t a7; const char* a8;} args;
		HxSemaphore lock;
		int ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::somePublicMethod(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4, data->args.a5, data->args.a6, data->args.a7, (const char*) data->args.a8);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {a0, a1, a2, a3, a4, a5, a6, a7, a8} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_throwException() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return test::HxPublicApi_obj::throwException();
	}

	// queue a callback to execute throwException() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::throwException();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_pack__ExampleClass_ExampleClassPrivate_examplePrivate() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return pack::_ExampleClass::ExampleClassPrivate_obj::examplePrivate();
	}

	// queue a callback to execute examplePrivate() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
		const char* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = pack::_ExampleClass::ExampleClassPrivate_obj::examplePrivate();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_pack_ExampleClass_example() {
	hx::NativeAttach autoAttach;
	if (HaxeEmbed::isMainThread()) {
		return pack::ExampleClass_obj::example();
	}

	// queue a callback to execute example() on the main thread and wait until execution completes
	struct Data {
		struct {} args;
		HxSemaphore lock;
		const char* ret;
	};

	struct Callback {
		static void run(void* p) {
			Data* data = (Data*) p;
			try {
				data->ret = pack::ExampleClass_obj::example();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	Data data = { {} };
	HaxeEmbed::queueOnMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

