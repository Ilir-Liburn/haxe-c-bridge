/**
 * HaxeCBridge Function Binding Implementation
 * Automatically generated by HaxeCBridge
 */
#include <hxcpp.h>
#include <hx/Native.h>
#include <hx/Thread.h>
#include <hx/StdLibs.h>
#include <hx/GC.h>
#include <HaxeCBridge.h>
#include <assert.h>
#include <queue>
#include <utility>
#include <atomic>

#include "../HaxeLib.h"

#include <test/HxPublicApi.h>
#include <haxe/ds/StringMap.h>
#include <_Main/CustomType.h>
#include <Main.h>
#include <pack/_ExampleClass/ExampleClassPrivate.h>
#include <pack/ExampleClass.h>
#include <Instance.h>

namespace HaxeCBridgeInternal {

	// we cannot use hxcpps HxCreateDetachedThread() because we cannot wait on these threads to end on unix because they are detached threads
	#if defined(HX_WINDOWS)
	HANDLE mainThreadNativeHandle = nullptr;
	HANDLE getNativeThreadHandle() {
		return GetCurrentThread();
	}
	bool createHaxeThread(DWORD (WINAPI *func)(void *), void *param, void *param) {
		return HxCreateDetachedThread(func, param);
	}
	bool waitForThreadExit(pthread_t handle) {
		DWORD result = WaitForSingleObject(handle, INFINITE);
		return result != WAIT_FAILED;
	}
	#else
	pthread_t mainThreadNativeHandle = nullptr;
	pthread_t getNativeThreadHandle() {
		return pthread_self();
	}
	bool createHaxeThread(void *(*func)(void *), void *param) {
		// same as HxCreateDetachedThread(func, param) but without detaching the thread
		pthread_t t;
		pthread_attr_t attr;
		if (pthread_attr_init(&attr) != 0)
			return false;
		if (pthread_create(&t, &attr, func, param) != 0 )
			return false;
		if (pthread_attr_destroy(&attr) != 0)
			return false;
		return true;
	}
	bool waitForThreadExit(pthread_t handle) {
		int result = pthread_join(handle, NULL);
		return result == 0;
	}
	#endif

	std::atomic<bool> threadStarted = { false };
	std::atomic<bool> threadRunning = { false };
	// once haxe statics are initialized we cannot clear them for a clean restart
	std::atomic<bool> staticsInitialized = { false };

	struct HaxeThreadData {
		HaxeExceptionCallback haxeExceptionCallback;
		const char* initExceptionInfo;
	};

	HxSemaphore threadInitSemaphore;
	HxMutex threadManageMutex;
	Dynamic mainThreadRef;

	void defaultExceptionHandler(const char* info) {
		printf("Unhandled haxe exception: %s\n", info);
	}

	typedef void (* MainThreadCallback)(void* data);
	HxMutex queueMutex;
	std::queue<std::pair<MainThreadCallback, void*>> queue;

	void runInMainThread(MainThreadCallback callback, void* data) {
		queueMutex.Lock();
		queue.push(std::make_pair(callback, data));
		queueMutex.Unlock();
		HaxeCBridge::wakeMainThread();
	}

	// called on the haxe main thread
	void processNativeCalls() {
		AutoLock lock(queueMutex);
		while(!queue.empty()) {
			std::pair<MainThreadCallback, void*> pair = queue.front();
			queue.pop();
			pair.first(pair.second);
		}
	}

	bool isHaxeMainThread() {
		hx::NativeAttach autoAttach;
		Dynamic currentInfo = __hxcpp_thread_current();
		return HaxeCBridgeInternal::mainThreadRef.mPtr == currentInfo.mPtr;
	}
}

THREAD_FUNC_TYPE haxeMainThreadFunc(void *data) {
	HX_TOP_OF_STACK
	HaxeCBridgeInternal::mainThreadNativeHandle = HaxeCBridgeInternal::getNativeThreadHandle();
	HaxeCBridgeInternal::HaxeThreadData* threadData = (HaxeCBridgeInternal::HaxeThreadData*) data;
	HaxeCBridgeInternal::mainThreadRef = __hxcpp_thread_current();

	HaxeCBridgeInternal::threadRunning = true; // must come after mainThreadRef assignment

	threadData->initExceptionInfo = nullptr;

	// copy out callback
	HaxeExceptionCallback haxeExceptionCallback = threadData->haxeExceptionCallback;

	bool firstRun = !HaxeCBridgeInternal::staticsInitialized;

	// See hx::Init in StdLibs.cpp for reference
	if (!HaxeCBridgeInternal::staticsInitialized) try {
		::hx::Boot();
		__boot_all();
		HaxeCBridgeInternal::staticsInitialized = true;
	} catch(Dynamic initException) {
		// hxcpp init failure or uncaught haxe runtime exception
		threadData->initExceptionInfo = initException->toString().utf8_str();
	}

	if (HaxeCBridgeInternal::staticsInitialized) { // initialized without error
		// blocks running the event loop
		// keeps alive until manual stop is called
		HaxeCBridge::mainThreadInit();
		HaxeCBridgeInternal::threadInitSemaphore.Set();
		HaxeCBridge::mainThreadRun(HaxeCBridgeInternal::processNativeCalls, haxeExceptionCallback);
	} else {
		// failed to initialize statics; unlock init semaphore so _initializeHaxeThread can continue and report the exception 
		HaxeCBridgeInternal::threadInitSemaphore.Set();
	}

	HaxeCBridgeInternal::threadRunning = false;

	THREAD_FUNC_RET
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
const char* HaxeLib_initializeHaxeThread(HaxeExceptionCallback unhandledExceptionCallback) {
	HaxeCBridgeInternal::HaxeThreadData threadData = {
		.haxeExceptionCallback = unhandledExceptionCallback == nullptr ? HaxeCBridgeInternal::defaultExceptionHandler : unhandledExceptionCallback,
		.initExceptionInfo = nullptr,
	};

	{
		// mutex prevents two threads calling this function from being able to start two haxe threads
		AutoLock lock(HaxeCBridgeInternal::threadManageMutex);
		if (!HaxeCBridgeInternal::threadStarted) {
			// startup the haxe main thread
			HaxeCBridgeInternal::createHaxeThread(haxeMainThreadFunc, &threadData);

			HaxeCBridgeInternal::threadStarted = true;

			// wait until the thread is initialized and ready
			HaxeCBridgeInternal::threadInitSemaphore.Wait();
		} else {
			threadData.initExceptionInfo = "haxe thread cannot be started twice";
		}
	}
				
	if (threadData.initExceptionInfo != nullptr) {
		HaxeLib_stopHaxeThreadIfRunning(false);

		const int returnInfoMax = 1024;
		static char returnInfo[returnInfoMax] = ""; // statically allocated for return safety
		strncpy(returnInfo, threadData.initExceptionInfo, returnInfoMax);
		return returnInfo;
	} else {
		return nullptr;
	}
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_stopHaxeThreadIfRunning(bool waitOnScheduledEvents) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		// it is possible for stopHaxeThread to be called from within the haxe thread, while another thread is waiting on for the thread to end
		// so it is important the haxe thread does not wait on certain locks
		HaxeCBridge::endMainThread(waitOnScheduledEvents);
	} else {
		AutoLock lock(HaxeCBridgeInternal::threadManageMutex);
		if (HaxeCBridgeInternal::threadRunning) {
			struct Callback {
				static void run(void* data) {
					bool* b = (bool*) data;
					HaxeCBridge::endMainThread(*b);
				}
			};

			HaxeCBridgeInternal::runInMainThread(Callback::run, &waitOnScheduledEvents);

			HaxeCBridgeInternal::waitForThreadExit(HaxeCBridgeInternal::mainThreadNativeHandle);
		}
	}
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_releaseHaxeObject(void* objPtr) {
	struct Callback {
		static void run(void* data) {
			HaxeCBridge::releaseHaxePtr(data);
		}
	};
	HaxeCBridgeInternal::runInMainThread(Callback::run, objPtr);
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_releaseHaxeString(const char* strPtr) {
	// we use the same release call for all haxe pointers
	HaxeLib_releaseHaxeObject((void*) strPtr);
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_voidRtn(int a0, HaxeString a1, HaxeLib_NonTrivialAlias a2, HaxeLib_EnumAlias a3) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::voidRtn(a0, a1, a2, a3);
	}
	struct Data {
		struct {int a0; HaxeString a1; HaxeLib_NonTrivialAlias a2; HaxeLib_EnumAlias a3;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::voidRtn(data->args.a0, data->args.a1, data->args.a2, data->args.a3);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2, a3} };

	// queue a callback to execute voidRtn() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeNoArgsNoReturn() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::noArgsNoReturn();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::noArgsNoReturn();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute noArgsNoReturn() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_callInMainThread(double a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::callInMainThread(a0);
	}
	struct Data {
		struct {double a0;} args;
		HxSemaphore lock;
		bool ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::callInMainThread(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute callInMainThread() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
bool HaxeLib_callInExternalThread(double a0) {
	hx::NativeAttach autoAttach;
	return test::HxPublicApi_obj::callInExternalThread(a0);
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_add(int a0, int a1) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::add(a0, a1);
	}
	struct Data {
		struct {int a0; int a1;} args;
		HxSemaphore lock;
		int ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::add(data->args.a0, data->args.a1);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1} };

	// queue a callback to execute add() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int* HaxeLib_starPointers(void* a0, HaxeLib_CppVoidX* a1, HaxeLib_CppVoidX* a2, int** a3, const void* a4, int* a5, const char* a6) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::starPointers(a0, a1, a2, a3, a4, a5, a6);
	}
	struct Data {
		struct {void* a0; HaxeLib_CppVoidX* a1; HaxeLib_CppVoidX* a2; int** a3; const void* a4; int* a5; const char* a6;} args;
		HxSemaphore lock;
		int* ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::starPointers(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4, data->args.a5, data->args.a6);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2, a3, a4, a5, a6} };

	// queue a callback to execute starPointers() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void* HaxeLib_rawPointers(void* a0, int64_t* a1, const void* a2) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::rawPointers(a0, a1, a2);
	}
	struct Data {
		struct {void* a0; int64_t* a1; const void* a2;} args;
		HxSemaphore lock;
		void* ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::rawPointers(data->args.a0, data->args.a1, data->args.a2);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2} };

	// queue a callback to execute rawPointers() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int64_t* HaxeLib_hxcppPointers(function_Bool_Void a0, void* a1, int64_t* a2, int a3, const void* a4) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::hxcppPointers(a0, a1, a2, a3, a4);
	}
	struct Data {
		struct {function_Bool_Void a0; void* a1; int64_t* a2; int a3; const void* a4;} args;
		HxSemaphore lock;
		int64_t* ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::hxcppPointers(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2, a3, a4} };

	// queue a callback to execute hxcppPointers() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
function_Int_cpp_ConstCharStar HaxeLib_hxcppCallbacks(function_Bool_Void a0, function_Void a1, function_Int a2, function_Int_cpp_ConstCharStar a3, function_cpp_Star_Int__cpp_Star_Int_ a4, HaxeLib_FunctionAlias a5, function_MessagePayload_Void a6) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::hxcppCallbacks(a0, a1, a2, a3, a4, a5, a6);
	}
	struct Data {
		struct {function_Bool_Void a0; function_Void a1; function_Int a2; function_Int_cpp_ConstCharStar a3; function_cpp_Star_Int__cpp_Star_Int_ a4; HaxeLib_FunctionAlias a5; function_MessagePayload_Void a6;} args;
		HxSemaphore lock;
		function_Int_cpp_ConstCharStar ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::hxcppCallbacks(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4, data->args.a5, data->args.a6);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2, a3, a4, a5, a6} };

	// queue a callback to execute hxcppCallbacks() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
MessagePayload HaxeLib_externStruct(MessagePayload a0, MessagePayload* a1) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::externStruct(a0, a1);
	}
	struct Data {
		struct {MessagePayload a0; MessagePayload* a1;} args;
		HxSemaphore lock;
		MessagePayload ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::externStruct(data->args.a0, data->args.a1);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1} };

	// queue a callback to execute externStruct() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_allocateABunchOfData() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::allocateABunchOfData();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::allocateABunchOfData();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute allocateABunchOfData() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_allocateABunchOfDataExternalThread() {
	hx::NativeAttach autoAttach;
	return test::HxPublicApi_obj::allocateABunchOfDataExternalThread();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
enum HaxeLib_IntEnum2 HaxeLib_enumTypes(enum HaxeLib_IntEnumAbstract a0, const char* a1, HaxeLib_EnumAlias a2) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return static_cast<enum HaxeLib_IntEnum2>(test::HxPublicApi_obj::enumTypes(a0, a1, a2));
	}
	struct Data {
		struct {enum HaxeLib_IntEnumAbstract a0; const char* a1; HaxeLib_EnumAlias a2;} args;
		HxSemaphore lock;
		enum HaxeLib_IntEnum2 ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = static_cast<enum HaxeLib_IntEnum2>(test::HxPublicApi_obj::enumTypes(data->args.a0, data->args.a1, data->args.a2));
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2} };

	// queue a callback to execute enumTypes() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_cppCoreTypes(size_t a0, char a1, const char* a2) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::cppCoreTypes(a0, a1, a2);
	}
	struct Data {
		struct {size_t a0; char a1; const char* a2;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::cppCoreTypes(data->args.a0, data->args.a1, data->args.a2);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2} };

	// queue a callback to execute cppCoreTypes() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
uint64_t HaxeLib_cppCoreTypes2(int a0, double a1, float a2, signed char a3, short a4, int a5, int64_t a6, uint64_t a7, const char* a8) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::cppCoreTypes2(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}
	struct Data {
		struct {int a0; double a1; float a2; signed char a3; short a4; int a5; int64_t a6; uint64_t a7; const char* a8;} args;
		HxSemaphore lock;
		uint64_t ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = test::HxPublicApi_obj::cppCoreTypes2(data->args.a0, data->args.a1, data->args.a2, data->args.a3, data->args.a4, data->args.a5, data->args.a6, data->args.a7, data->args.a8);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2, a3, a4, a5, a6, a7, a8} };

	// queue a callback to execute cppCoreTypes2() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
HaxeObject HaxeLib_createHaxeAnon() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return HaxeCBridge::retainHaxeObject(test::HxPublicApi_obj::createHaxeAnon());
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
		HaxeObject ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = HaxeCBridge::retainHaxeObject(test::HxPublicApi_obj::createHaxeAnon());
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute createHaxeAnon() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_checkHaxeAnon(HaxeObject a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::checkHaxeAnon(Dynamic((hx::Object *)a0));
	}
	struct Data {
		struct {HaxeObject a0;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::checkHaxeAnon(Dynamic((hx::Object *)data->args.a0));
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute checkHaxeAnon() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_checkAnonFromPointer(void* a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::checkAnonFromPointer(a0);
	}
	struct Data {
		struct {void* a0;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::checkAnonFromPointer(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute checkAnonFromPointer() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
HaxeObject HaxeLib_createHaxeMap() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return HaxeCBridge::retainHaxeObject(test::HxPublicApi_obj::createHaxeMap());
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
		HaxeObject ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = HaxeCBridge::retainHaxeObject(test::HxPublicApi_obj::createHaxeMap());
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute createHaxeMap() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_checkHaxeMap(HaxeObject a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::checkHaxeMap(Dynamic((hx::Object *)a0));
	}
	struct Data {
		struct {HaxeObject a0;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::checkHaxeMap(Dynamic((hx::Object *)data->args.a0));
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute checkHaxeMap() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_checkNull(HaxeObject a0, double a1) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::checkNull(Dynamic((hx::Object *)a0), a1);
	}
	struct Data {
		struct {HaxeObject a0; double a1;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::checkNull(Dynamic((hx::Object *)data->args.a0), data->args.a1);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1} };

	// queue a callback to execute checkNull() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
HaxeObject HaxeLib_createCustomType() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return HaxeCBridge::retainHaxeObject(test::HxPublicApi_obj::createCustomType());
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
		HaxeObject ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = HaxeCBridge::retainHaxeObject(test::HxPublicApi_obj::createCustomType());
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute createCustomType() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_checkCustomType(HaxeObject a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::checkCustomType(Dynamic((hx::Object *)a0));
	}
	struct Data {
		struct {HaxeObject a0;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::checkCustomType(Dynamic((hx::Object *)data->args.a0));
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute checkCustomType() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
HaxeString HaxeLib_createHaxeString() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return HaxeCBridge::retainHaxeString(test::HxPublicApi_obj::createHaxeString());
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
		HaxeString ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = HaxeCBridge::retainHaxeString(test::HxPublicApi_obj::createHaxeString());
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute createHaxeString() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_checkHaxeString(HaxeString a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::checkHaxeString(a0);
	}
	struct Data {
		struct {HaxeString a0;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::checkHaxeString(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute checkHaxeString() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_throwException() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return test::HxPublicApi_obj::throwException();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				test::HxPublicApi_obj::throwException();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute throwException() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_Main_stopLoopingAfterTime_ms(int a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return Main_obj::stopLoopingAfterTime_ms(a0);
	}
	struct Data {
		struct {int a0;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				Main_obj::stopLoopingAfterTime_ms(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute stopLoopingAfterTime_ms() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_Main_getLoopCount() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return Main_obj::getLoopCount();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
		int ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = Main_obj::getLoopCount();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute getLoopCount() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_Main_hxcppGcMemUsage() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return Main_obj::hxcppGcMemUsage();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
		int ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = Main_obj::hxcppGcMemUsage();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute hxcppGcMemUsage() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_Main_hxcppGcMemUsageExternal() {
	hx::NativeAttach autoAttach;
	return Main_obj::hxcppGcMemUsageExternal();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_Main_hxcppGcRun(bool a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return Main_obj::hxcppGcRun(a0);
	}
	struct Data {
		struct {bool a0;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				Main_obj::hxcppGcRun(data->args.a0);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute hxcppGcRun() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_Main_printTime() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return Main_obj::printTime();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				Main_obj::printTime();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute printTime() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_pack__ExampleClass_ExampleClassPrivate_examplePrivate() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return pack::_ExampleClass::ExampleClassPrivate::examplePrivate();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
		int ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = pack::_ExampleClass::ExampleClassPrivate::examplePrivate();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute examplePrivate() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int ExamplePrefix_example() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return pack::ExampleClass_obj::example();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
		int ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = pack::ExampleClass_obj::example();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute example() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
HaxeObject HaxeLib_Instance_new(HaxeString a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return HaxeCBridge::retainHaxeObject(Instance_obj::__new(a0));
	}
	struct Data {
		struct {HaxeString a0;} args;
		HxSemaphore lock;
		HaxeObject ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = HaxeCBridge::retainHaxeObject(Instance_obj::__new(data->args.a0));
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute new() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_Instance_methodNoArgs(HaxeObject a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return (Instance((hx::Object *)a0, true))->methodNoArgs();
	}
	struct Data {
		struct {HaxeObject a0;} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				(Instance((hx::Object *)data->args.a0, true))->methodNoArgs();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute methodNoArgs() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
int HaxeLib_Instance_methodAdd(HaxeObject a0, int a1, int a2) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return (Instance((hx::Object *)a0, true))->methodAdd(a1, a2);
	}
	struct Data {
		struct {HaxeObject a0; int a1; int a2;} args;
		HxSemaphore lock;
		int ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = (Instance((hx::Object *)data->args.a0, true))->methodAdd(data->args.a1, data->args.a2);
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0, a1, a2} };

	// queue a callback to execute methodAdd() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
HaxeString HaxeLib_Instance_overrideMe(HaxeObject a0) {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return HaxeCBridge::retainHaxeString((Instance((hx::Object *)a0, true))->overrideMe());
	}
	struct Data {
		struct {HaxeObject a0;} args;
		HxSemaphore lock;
		HaxeString ret;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				data->ret = HaxeCBridge::retainHaxeString((Instance((hx::Object *)data->args.a0, true))->overrideMe());
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {a0} };

	// queue a callback to execute overrideMe() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
	return data.ret;
}

HXCPP_EXTERN_CLASS_ATTRIBUTES
void HaxeLib_Instance_staticMethod() {
	if (HaxeCBridgeInternal::isHaxeMainThread()) {
		return Instance_obj::staticMethod();
	}
	struct Data {
		struct {} args;
		HxSemaphore lock;
	};
	struct Callback {
		static void run(void* p) {
			// executed within the haxe main thread
			Data* data = (Data*) p;
			try {
				Instance_obj::staticMethod();
				data->lock.Set();
			} catch(Dynamic runtimeException) {
				data->lock.Set();
				throw runtimeException;
			}
		}
	};

	#ifdef HXCPP_DEBUG
	assert(HaxeCBridgeInternal::threadRunning && "haxe thread not running, use HaxeLib_initializeHaxeThread() to activate the haxe thread");
	#endif

	Data data = { {} };

	// queue a callback to execute staticMethod() on the main thread and wait until execution completes
	HaxeCBridgeInternal::runInMainThread(Callback::run, &data);
	data.lock.Wait();
}

